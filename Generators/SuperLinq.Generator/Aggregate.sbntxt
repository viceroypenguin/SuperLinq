{{ 
    $arity = arity
    $ordinals = ordinals
}}

namespace SuperLinq;

public static partial class SuperEnumerable
{
	{{~ for $i in 2..($arity.size - 1) ~}}
    /// <summary>
    /// Applies {{ $arity[$i] }} accumulators sequentially in a single pass over a
    /// sequence.
    /// </summary>
    /// <typeparam name="T">The type of elements in <paramref name="source"/>.</typeparam>
    /// <typeparam name="TResult">The type of the accumulated result.</typeparam>
    /// <param name="source">The source sequence</param>
    /// <param name="resultSelector">
    /// A function that projects a single result given the result of each
    /// accumulator.</param>
    /// <returns>The value returned by <paramref name="resultSelector"/>.</returns>
    /// <remarks>
    /// This operator executes immediately.
    /// </remarks>
	{{~ for $j in 1..$i ~}}
    /// <typeparam name="TAccumulate{{$j}}">The type of the {{ $ordinals[$j] }} accumulator value.</typeparam>
	/// <param name="seed{{$j}}">The seed value for the {{ $ordinals[$j] }} accumulator.</param>
	/// <param name="accumulator{{$j}}">The {{ $ordinals[$j] }} accumulator.</param>
	{{~ end ~}}
    public static TResult Aggregate<T, {{ for $j in 1..$i }}TAccumulate{{$j}}, {{ end }}TResult>(
        this IEnumerable<T> source,
		{{~ for $j in 1..$i ~}}
        TAccumulate{{$j}} seed{{$j}}, Func<TAccumulate{{$j}}, T, TAccumulate{{$j}}> accumulator{{$j}},
		{{~ end ~}}
        Func<{{ for $j in 1..$i }}TAccumulate{{$j}}, {{ end }}TResult> resultSelector)
	{
		Guard.IsNotNull(source);

		{{~ for $j in 1..$i ~}}
        Guard.IsNotNull(accumulator{{$j}});
		{{~ end ~}}

        Guard.IsNotNull(resultSelector);

		foreach (var item in source)
		{
			{{~ for $j in 1..$i ~}}
		    seed{{$j}} = accumulator{{$j}}(seed{{$j}}, item);
		    {{~ end ~}}
		}

		return resultSelector(
			{{~ for $j in 1..$i ~}}
		    seed{{$j}}{{ if !for.last }},{{ end }}
		    {{~ end ~}}
        );
	}
	{{ end ~}}
}
