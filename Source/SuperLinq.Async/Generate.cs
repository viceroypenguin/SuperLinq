namespace SuperLinq.Async;

public static partial class AsyncSuperEnumerable
{
	/// <summary>
	/// Returns a sequence of values consecutively generated by a generator function.
	/// </summary>
	/// <typeparam name="TResult">Type of elements to generate.</typeparam>
	/// <param name="initial">Value of first element in sequence</param>
	/// <param name="generator">
	/// Generator function which takes the previous series element and uses it to generate the next element.
	/// </param>
	/// <returns>A sequence containing the generated values.</returns>
	/// <exception cref="ArgumentNullException"><paramref name="generator"/> is <see langword="null"/>.</exception>
	/// <remarks>
	/// This function defers element generation until needed and streams the results.
	/// </remarks>
	/// <example>
	/// <code><![CDATA[
	/// var result = AsyncSuperEnumerable.Generate(2, n => n * n).Take(5);
	/// ]]></code>
	/// The <c>result</c> variable, when iterated over, will yield 2, 4, 16, 256, and 65536, in turn.
	/// </example>
	public static IAsyncEnumerable<TResult> Generate<TResult>(TResult initial, Func<TResult, ValueTask<TResult>> generator)
	{
		ArgumentNullException.ThrowIfNull(generator);
		return Generate(initial, (r, ct) => generator(r));
	}

	/// <summary>
	/// Returns a sequence of values consecutively generated by a generator function.
	/// </summary>
	/// <typeparam name="TResult">Type of elements to generate.</typeparam>
	/// <param name="initial">Value of first element in sequence</param>
	/// <param name="generator">
	/// Generator function which takes the previous series element and uses it to generate the next element.
	/// </param>
	/// <returns>A sequence containing the generated values.</returns>
	/// <exception cref="ArgumentNullException"><paramref name="generator"/> is <see langword="null"/>.</exception>
	/// <remarks>
	/// This function defers element generation until needed and streams the results.
	/// </remarks>
	/// <example>
	/// <code><![CDATA[
	/// var result = AsyncSuperEnumerable.Generate(2, n => n * n).Take(5);
	/// ]]></code>
	/// The <c>result</c> variable, when iterated over, will yield 2, 4, 16, 256, and 65536, in turn.
	/// </example>
	public static IAsyncEnumerable<TResult> Generate<TResult>(TResult initial, Func<TResult, CancellationToken, ValueTask<TResult>> generator)
	{
		ArgumentNullException.ThrowIfNull(generator);

		return Core(initial, generator);

		static async IAsyncEnumerable<TResult> Core(TResult current, Func<TResult, CancellationToken, ValueTask<TResult>> generator, [EnumeratorCancellation] CancellationToken cancellationToken = default)
		{
			while (true)
			{
				yield return current;
				current = await generator(current, cancellationToken).ConfigureAwait(false);
			}
		}
	}
}
